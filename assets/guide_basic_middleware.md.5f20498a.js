import{_ as s,c as a,o as n,O as e}from"./chunks/framework.d7e37bdc.js";const p="/assets/middleware-model.ba23fdeb.png",h=JSON.parse('{"title":"中间件 (Middleware)","description":"","frontmatter":{},"headers":[],"relativePath":"guide/basic/middleware.md","filePath":"guide/basic/middleware.md","lastUpdated":1677953005000}'),l={name:"guide/basic/middleware.md"},o=e(`<h1 id="中间件-middleware" tabindex="-1">中间件 (Middleware) <a class="header-anchor" href="#中间件-middleware" aria-label="Permalink to &quot;中间件 (Middleware)&quot;">​</a></h1><p>相比事件，中间件只能处理消息流。但其更为灵活，同时提供了事件所不具有的能力——截断处理。</p><p>定义一个中间件：</p><div class="language-csharp vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">csharp</span><pre class="shiki github-dark vp-code-dark"><code><span class="line"><span style="color:#E1E4E8;">app.</span><span style="color:#B392F0;">UseMiddleware</span><span style="color:#E1E4E8;">(</span><span style="color:#F97583;">async</span><span style="color:#E1E4E8;"> (</span><span style="color:#B392F0;">ctx</span><span style="color:#E1E4E8;">, </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">) </span><span style="color:#F97583;">=&gt;</span><span style="color:#E1E4E8;"> {</span></span>
<span class="line"><span style="color:#E1E4E8;">    </span><span style="color:#F97583;">if</span><span style="color:#E1E4E8;"> (ctx.Message.</span><span style="color:#B392F0;">GetText</span><span style="color:#E1E4E8;">() </span><span style="color:#F97583;">==</span><span style="color:#E1E4E8;"> </span><span style="color:#9ECBFF;">&quot;pass me!&quot;</span><span style="color:#E1E4E8;">)</span></span>
<span class="line"><span style="color:#E1E4E8;">        </span><span style="color:#F97583;">await</span><span style="color:#E1E4E8;"> </span><span style="color:#B392F0;">next</span><span style="color:#E1E4E8;">();</span></span>
<span class="line"><span style="color:#E1E4E8;">});</span></span></code></pre><pre class="shiki github-light vp-code-light"><code><span class="line"><span style="color:#24292E;">app.</span><span style="color:#6F42C1;">UseMiddleware</span><span style="color:#24292E;">(</span><span style="color:#D73A49;">async</span><span style="color:#24292E;"> (</span><span style="color:#6F42C1;">ctx</span><span style="color:#24292E;">, </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">) </span><span style="color:#D73A49;">=&gt;</span><span style="color:#24292E;"> {</span></span>
<span class="line"><span style="color:#24292E;">    </span><span style="color:#D73A49;">if</span><span style="color:#24292E;"> (ctx.Message.</span><span style="color:#6F42C1;">GetText</span><span style="color:#24292E;">() </span><span style="color:#D73A49;">==</span><span style="color:#24292E;"> </span><span style="color:#032F62;">&quot;pass me!&quot;</span><span style="color:#24292E;">)</span></span>
<span class="line"><span style="color:#24292E;">        </span><span style="color:#D73A49;">await</span><span style="color:#24292E;"> </span><span style="color:#6F42C1;">next</span><span style="color:#24292E;">();</span></span>
<span class="line"><span style="color:#24292E;">});</span></span></code></pre></div><p>上面的中间件达到了一个效果：只有在消息文本为 <code>pass me!</code> 的时候，消息才会被传送至下一步处理。否则，消息将在此处被截断，不会向下传播。</p><p>Flandre 的中间件设计参考了洋葱模型。如果你有使用 ASP.NET Core 中间件，或是 Node.js 框架 Koa 的经验，就很容易理解。这里采用一张来自 ASP.NET Core 文档的图片来说明：</p><p><img src="`+p+'" alt="中间件模型"></p>',7),t=[o];function c(r,E,d,i,y,_){return n(),a("div",null,t)}const u=s(l,[["render",c]]);export{h as __pageData,u as default};
